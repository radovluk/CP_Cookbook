#!/usr/bin/env python3
"""
Compare constraints generated by Original and Simplified RCPSP-AS models.

Usage:
    python compare_models.py <instance_path>

Example:
    python compare_models.py ../../data/rcpspas/robot-example/robot-example_a.rcp
    python compare_models.py ../../data/rcpspas/ASLIB/ASLIB0/aslib0_25678a.RCP
"""

import sys
from ascp.load_instance import load_instance


def compare_models(instance_path: str):
    instance = load_instance(instance_path)

    print("=" * 70)
    print(f"INSTANCE: {instance.name}")
    print("=" * 70)

    # Build act_dict
    act_dict = {act.id: act for act in instance.activities}
    n = len(instance.activities)

    # Helper function to convert 0-based index to 1-based for display
    def idx(i):
        return i + 1

    print(f"\nActivities (N): {[idx(i) for i in act_dict.keys()]}")
    print(f"Number of activities: {n}")
    print(f"Subgraphs (L): {[(idx(s.principal_activity), list(s.branches)) for s in instance.subgraphs]}")
    print(f"Resources: {instance.resources}")

    # Build precedence arcs A
    A = []
    for act in instance.activities:
        for j in act.successors:
            if j in act_dict:
                A.append((act.id, j))

    print(f"\nPrecedence arcs (A): {len(A)} arcs")
    for (i, j) in A:
        print(f"  ({idx(i)}, {idx(j)})")

    # Build branching_arcs for simplified model
    branching_arcs = {
        (sub.principal_activity, s)
        for sub in instance.subgraphs if sub.principal_activity in act_dict
        for s in act_dict[sub.principal_activity].successors if s in act_dict
    }

    A_prop = [(i, j) for (i, j) in A if (i, j) not in branching_arcs]

    print(f"\nBranching arcs: {[(idx(i), idx(j)) for (i, j) in branching_arcs]}")
    print(f"Non-branching arcs (A_prop): {len(A_prop)} arcs")

    # Build M map for original model
    M = {
        branch_id: b_k_act_id
        for sub in instance.subgraphs if sub.principal_activity in act_dict
        for b_k_act_id in act_dict[sub.principal_activity].successors if b_k_act_id in act_dict
        for branch_id in act_dict[b_k_act_id].branches.intersection(sub.branches) if branch_id != 0
    }
    M[0] = 0

    M_display = {k: idx(v) for k, v in M.items()}
    print(f"\nBranch map M (branch_id → branching_activity): {M_display}")

    print("\nActivity branches:")
    for i, act in act_dict.items():
        print(f"  Activity {idx(i)}: branches = {act.branches}, duration = {act.duration}")

    # =========================================================================
    # MODEL 1: ORIGINAL
    # =========================================================================
    print("\n" + "=" * 70)
    print("MODEL 1: ORIGINAL (rcpspas.ipynb)")
    print("=" * 70)

    print("\n--- (1) Objective ---")
    print(f"  min endOf(x[{idx(n-1)}])")

    print("\n--- (2) Source activity ---")
    print("  presenceOf(x[1]) = 1")

    print("\n--- (3) Precedence (ALL arcs) ---")
    for (i, j) in A:
        print(f"  if_then(presenceOf(x[{idx(i)}]) ∧ presenceOf(x[{idx(j)}]), endOf(x[{idx(i)}]) ≤ startOf(x[{idx(j)}]))")

    print("\n--- (4) Branch selection ---")
    for sub in instance.subgraphs:
        if sub.principal_activity in act_dict:
            successors = [s for s in act_dict[sub.principal_activity].successors if s in act_dict]
            print(f"  Σ presenceOf(x[{[idx(s) for s in successors]}]) = presenceOf(x[{idx(sub.principal_activity)}])")

    print("\n--- (5) Activity selection (unified) ---")
    for i, act in act_dict.items():
        if i != 0:
            branch_vars = [M[b_id] for b_id in act.branches if b_id in M]
            print(f"  presenceOf(x[{idx(i)}]) = (Σ presenceOf(x[{[idx(v) for v in branch_vars]}]) > 0)")

    print("\n--- (6) Resource constraints ---")
    for v, capacity in enumerate(instance.resources):
        if capacity > 0:
            activities_with_demand = [idx(act.id) for act in instance.activities if act.requirements[v] > 0]
            print(f"  Σ pulse(x[{activities_with_demand}], r[i,{v+1}]) ≤ {capacity}")

    # Count constraints
    orig_constraints = 1 + len(A) + len(instance.subgraphs) + (n - 1) + len([c for c in instance.resources if c > 0])

    # =========================================================================
    # MODEL 2: SIMPLIFIED
    # =========================================================================
    print("\n" + "=" * 70)
    print("MODEL 2: SIMPLIFIED (rcpsp-as-simplified.ipynb)")
    print("=" * 70)

    print("\n--- (1) Objective ---")
    print(f"  min endOf(x[{idx(n-1)}])")

    print("\n--- (2) Source activity ---")
    print("  presenceOf(x[1]) = 1")

    print("\n--- (3) Selection propagation (A_prop only) ---")
    for (i, j) in A_prop:
        print(f"  presenceOf(x[{idx(i)}]) ≤ presenceOf(x[{idx(j)}])")

    print("\n--- (4) Branch selection ---")
    for sub in instance.subgraphs:
        if sub.principal_activity in act_dict:
            successors = [s for s in act_dict[sub.principal_activity].successors if s in act_dict]
            print(f"  Σ presenceOf(x[{[idx(s) for s in successors]}]) = presenceOf(x[{idx(sub.principal_activity)}])")

    print("\n--- (5) Precedence (ALL arcs) ---")
    for (i, j) in A:
        print(f"  if_then(presenceOf(x[{idx(i)}]) ∧ presenceOf(x[{idx(j)}]), endOf(x[{idx(i)}]) ≤ startOf(x[{idx(j)}]))")

    print("\n--- (6) Resource constraints ---")
    for v, capacity in enumerate(instance.resources):
        if capacity > 0:
            activities_with_demand = [idx(act.id) for act in instance.activities if act.requirements[v] > 0]
            print(f"  Σ pulse(x[{activities_with_demand}], r[i,{v+1}]) ≤ {capacity}")

    # Count constraints
    simp_constraints = 1 + len(A_prop) + len(instance.subgraphs) + len(A) + len([c for c in instance.resources if c > 0])

    # =========================================================================
    # SUMMARY
    # =========================================================================
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    print(f"\nOriginal model:")
    print(f"  - Source constraint: 1")
    print(f"  - Precedence constraints: {len(A)}")
    print(f"  - Branch selection constraints: {len(instance.subgraphs)}")
    print(f"  - Activity selection constraints: {n - 1}")
    print(f"  - Resource constraints: {len([c for c in instance.resources if c > 0])}")
    print(f"  - TOTAL: {orig_constraints}")

    print(f"\nSimplified model:")
    print(f"  - Source constraint: 1")
    print(f"  - Selection propagation constraints: {len(A_prop)}")
    print(f"  - Branch selection constraints: {len(instance.subgraphs)}")
    print(f"  - Precedence constraints: {len(A)}")
    print(f"  - Resource constraints: {len([c for c in instance.resources if c > 0])}")
    print(f"  - TOTAL: {simp_constraints}")

    print(f"\nDifference: {orig_constraints - simp_constraints} constraints")

    # Check for activities in multiple branches (potential issue)
    print("\n" + "=" * 70)
    print("ACTIVITIES IN MULTIPLE BRANCHES (potential difference)")
    print("=" * 70)
    multi_branch = [(i, act.branches) for i, act in act_dict.items() if len(act.branches) > 1]
    if multi_branch:
        for i, branches in multi_branch:
            branch_acts = [M[b_id] for b_id in branches if b_id in M]
            print(f"  Activity {idx(i)}: branches {branches} → branching activities {[idx(a) for a in branch_acts]}")
            print(f"    Original: presenceOf(x[{idx(i)}]) = (Σ presenceOf(x[{[idx(a) for a in branch_acts]}]) > 0)")
            print(f"    Simplified: implied by propagation from predecessors")
    else:
        print("  None - all activities belong to exactly one branch")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    compare_models(sys.argv[1])
